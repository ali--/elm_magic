# -*- coding: utf-8 -*-

from collections import deque
import contextlib
import io
import os
import subprocess
import sys
from IPython.core.display import display_javascript
from IPython.core.display import display, Javascript, HTML
from IPython.core.display import clear_output
from IPython.core.magic import (Magics, magics_class, line_magic,
                                cell_magic, line_cell_magic)

from IPython.core.magic_arguments import argument, magic_arguments, parse_argstring

from tempfile import TemporaryDirectory

try:
    from traitlets.config.configurable import Configurable
    from traitlets import Bool, Int, Unicode
except ImportError:
    from IPython.config.configurable import Configurable
    from IPython.utils.traitlets import Bool, Int, Unicode


def _create_success_js(js,div_id):
    """create html with the results of a successful compilation.
    `js` is the javascript generated by elm-make.
    `div_id` is the id of the html element that Elm will embed int
    """
    module_name = "Main"
    template = """
        <div id="{div_id}"></div>
        <script>
            var defineElm = function(cb) {{
                if (this.Elm) {{
                    this.oldElm = this.Elm;
                }}
                var define = null;
                {js}
                cb();
            }}
            ;
            var obj = new Object();
            defineElm.bind(obj)(function(){{
                var mountNode = document.getElementById('{div_id}');
                obj.Elm. {module_name}.embed(mountNode);
            }});
        </script>
    """

    js = template.format(
        js=js,
        module_name=module_name,
        div_id=div_id)
    
    return js

def elm_package_install(package,workdir):
    try:
        out = subprocess.check_output(
                 ['elm-package', 'install' , package, '--yes'],
                 cwd=workdir,
                 stderr=subprocess.STDOUT
              )
        print("Installed elm package {} in {}: {}".format(package,workdir,out))

    except subprocess.CalledProcessError as err:
        return CompilationFailure("CompilationFailed: \n" + err.stdout.decode('UTF-8'))
            

@magics_class
class ElmMagic(Magics, Configurable):
    """Compiles elm-lang code and displays result
       as html/js.  It can be configured to use either a temporary
       or user-specified directory for compilation 
    """

    elmdir = Unicode(value='',config=True, help="Directory where elm-make will run. (This is where elm-stuff and elm-package.json will be). Uses a temporary directory if not set by user")
    keep_sources = Bool(False, config=True, help="Do not immediately delete the html/js generated by compilation")

    def __init__(self, shell):
        # You must call the parent constructor
        Configurable.__init__(self,config=shell.config)
        Magics.__init__(self,shell=shell)

        self._tempdir = None
        self._execution_count = 0

        # Add ourself to the list of module configurable via %config
        self.shell.configurables.append(self)

    @property
    def _workdir(self):
        if self.elmdir != '':
            if not os.path.isdir(self.elmdir):
                os.makedirs(self.elmdir)
            return self.elmdir

        if not self._tempdir:
            self._tempdir = TemporaryDirectory()

        return self._tempdir.name
        
    @magic_arguments()
    @cell_magic
    @argument('-i','--install', type=str, nargs='+',action='append',help="install elm packages")
    @argument('-w','--workdir', type=str,help="location for elm-make to run")
    @argument('-k','--keep', type=bool,help="dont autodelete elm js sources")
    @argument('-r','--render', type=bool,help="serverside render html (alpha)")
    def elm(self,arg=None, cell=None):
        """Compile and display Elm code"""

        args = parse_argstring(self.elm, arg)
        if args.workdir:
            self.elmdir = args.workdir

        if args.keep:
            self.keep_sources = True

        if args.install:
            packages = args.install[0]
            for p in packages:
                elm_package_install(p,self._workdir)

        if cell is None:
            print("Please use as cell-magic (use second line)")
            return 

        print("Compiling Elm in workdir {}".format(self._workdir))
        
        self._execution_count += 1
        div_id = 'elm-div-'+str(self._execution_count)

       # print("compiling\n{}".format(cell))

        if args.render == True:
            result = ElmRenderer(self._workdir,self.keep_sources).do_compile(cell)
            display(HTML(result._js))
            return

        result = ElmCompiler(self._workdir,self.keep_sources).do_compile(cell)

        clear_output
        result.display(div_id)

class CompilationResult:
    pass

class CompilationSuccess(CompilationResult):
    def __init__(self,js):
        self._js = js
        
    def display(self,div_id):        
        js = _create_success_js(self._js,div_id)
        display(HTML(js))

class CompilationNOOP(CompilationResult):
    
    def display(self,div_id):
        display(HTML("<h1 id='{div_id}'>Ok</h1>".format(div_id)))
        
class CompilationFailure(CompilationResult):
    
    def __init__(self,msg):
        self._msg = msg
    
    def display(self,div_id):
        lines = self._msg.split('\n')
        html = "<div id='{}'>".format(div_id) \
               + ' '.join(['<pre>{}</pre>'.format(line) for line in lines]) \
               + "</div>"
        display(HTML(html))
    
class ElmCompiler:
    """Wrapper around elm-make to return compiled JS string from Elm source.  
       By default, removes generated sources immediately after compilation
    """

    def __init__(self, workdir=None, keep_sources=False):
        self._code = []
        self._keep_sources = keep_sources
        self._workdir = workdir
        self._tempdir = None

        if not self._workdir:
            self._tempdir = TemporaryDirectory()
            self._workdir = self._tempdir.name
            
    def do_compile(self, code):
        """ Returns instance of CompilationResult """
        self._code.append(code)
        if self._should_compile:
            try:
                code = "\n".join(self._code)
                self._code = []
                return self._compile(code)
            except Exception as exc:
                return CompilationFailure(str(exc))

        return CompilationNOOP()

    @contextlib.contextmanager
    def _tempfile(self, filename):
        """Yield `filename` inside the workdir, but don't actually create the file.
        Then, on exit, delete the file if it exists.
        """
        try:
            path = os.path.join(self._workdir, filename)
            yield path
        finally:
            with contextlib.suppress(OSError):
                if not self._keep_sources:
                    os.remove(path)

    def _compile(self, code):
        with self._tempfile('Main.elm') as infile,\
             self._tempfile('elm.js') as outfile:

            with open(infile, mode='wt') as f:
                f.write(code)

            try:
                out = self.run_compile_command(self._workdir,infile,outfile)
                
                with open(outfile, mode='rt') as f:
                    javascript = f.read()
                
                return CompilationSuccess(javascript)

            except subprocess.CalledProcessError as err:
                # When compilation fails we send the compiler output to the
                # user but we don't count this as an error. A compiler error
                # might actually be the desired output of the cell.
                return CompilationFailure("CompilationFailed: \n" + err.stdout.decode('UTF-8'))
            except FileNotFoundError as err:
                return CompilationFailure("FileNotfound: \n {}".format(err))
            except Exception as err:
                return CompilationFailure("Exception: \n" + str(err) + '\n' + err.stdout.decode('UTF-8'))

    def run_compile_command(self,workdir,infile,outfile):
            out = subprocess.check_output(
                ['elm-make', infile, '--yes',
                    '--output={}'.format(outfile)],
                cwd=workdir,
                stderr=subprocess.STDOUT)
            return out

    @property
    def _should_compile(self):
        """Hook for conditional compilation later. (TODO)"""
        return True
 
class ElmRenderer(ElmCompiler):
    """Wrapper around elm-make to return compiled JS string from Elm source.  
       By default, removes generated sources immediately after compilation
    """
    def run_compile_command(self,workdir,infile,outfile):
         out = subprocess.check_output(
                ['node', 'elm-static-html', '-f', infile, '--output', outfile],
                cwd=workdir,
                stderr=subprocess.STDOUT)
         return out

                
def load_ipython_extension(ip):
    """Load the extension in IPython."""
    #js = "IPython.CodeCell.config_defaults.highlight_modes['magic_sql'] = {'reg':[/^%%elm/]};"
    #display(Javascript(js))
    magics = ElmMagic(ip)
    ip.register_magics(magics)
